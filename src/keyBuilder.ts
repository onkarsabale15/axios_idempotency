import crypto from 'crypto';
import { AxiosRequestConfig } from 'axios';
import { IdempotencyKeyInclude } from './types';

/**
 * Build an idempotency key from an Axios request configuration
 * 
 * The key is generated by:
 * 1. Extracting configured request parts (method, path, query, headers, body)
 * 2. Serializing them deterministically
 * 3. Hashing with SHA-256
 * 4. Prefixing with "axios-idempotent:"
 * 
 * @param config - Axios request configuration
 * @param include - Configuration for which parts to include
 * @returns The generated idempotency key
 */
export function buildIdempotencyKey(
  config: AxiosRequestConfig,
  include: IdempotencyKeyInclude = {}
): string {
  const parts: Record<string, any> = {};

  // Always include method (normalized to uppercase)
  parts.method = (config.method || 'GET').toUpperCase();

  // Include path if configured
  if (include.path !== false) {
    parts.path = extractPath(config.url || '');
  }

  // Include query parameters if configured
  if (include.query) {
    parts.query = extractQuery(config.url || '', config.params, include.query);
  }

  // Include headers if configured
  if (include.headers && Array.isArray(include.headers) && include.headers.length > 0) {
    parts.headers = extractHeaders(config.headers || {}, include.headers);
  }

  // Include body if configured
  if (include.body && config.data) {
    parts.body = normalizeBody(config.data);
  }

  // Serialize deterministically and hash
  const serialized = JSON.stringify(parts, Object.keys(parts).sort());
  const hash = crypto.createHash('sha256').update(serialized).digest('hex');

  return `axios-idempotent:${hash}`;
}

/**
 * Extract the path component from a URL
 */
function extractPath(url: string): string {
  try {
    // Handle relative URLs
    if (url.startsWith('/')) {
      return url.split('?')[0];
    }

    // Handle absolute URLs
    const urlObj = new URL(url);
    return urlObj.pathname;
  } catch {
    // Fallback for malformed URLs
    return url.split('?')[0];
  }
}

/**
 * Extract query parameters from URL and params object
 */
function extractQuery(
  url: string,
  params: any,
  queryConfig: boolean | string[]
): Record<string, any> {
  const query: Record<string, any> = {};

  // Extract from URL
  try {
    let searchParams: URLSearchParams;
    
    if (url.includes('?')) {
      const queryString = url.split('?')[1];
      searchParams = new URLSearchParams(queryString);
    } else {
      searchParams = new URLSearchParams();
    }

    searchParams.forEach((value, key) => {
      query[key] = value;
    });
  } catch {
    // Ignore URL parsing errors
  }

  // Merge with params object
  if (params && typeof params === 'object') {
    Object.assign(query, params);
  }

  // Filter to specific params if configured
  if (Array.isArray(queryConfig)) {
    const filtered: Record<string, any> = {};
    for (const key of queryConfig) {
      if (key in query) {
        filtered[key] = query[key];
      }
    }
    return filtered;
  }

  return query;
}

/**
 * Extract specific headers from request headers
 */
function extractHeaders(
  headers: Record<string, any>,
  headerNames: string[]
): Record<string, any> {
  const extracted: Record<string, any> = {};

  for (const name of headerNames) {
    // Case-insensitive header matching
    const lowerName = name.toLowerCase();
    
    for (const [key, value] of Object.entries(headers)) {
      if (key.toLowerCase() === lowerName) {
        extracted[lowerName] = value;
        break;
      }
    }
  }

  return extracted;
}

/**
 * Normalize request body for consistent hashing
 */
function normalizeBody(data: any): any {
  if (typeof data === 'string') {
    try {
      // Try to parse JSON strings for normalization
      return JSON.parse(data);
    } catch {
      return data;
    }
  }

  if (data instanceof FormData || data instanceof URLSearchParams) {
    // For FormData and URLSearchParams, convert to object
    const obj: Record<string, any> = {};
    data.forEach((value: any, key: string) => {
      obj[key] = value;
    });
    return obj;
  }

  // Return as-is for objects and other types
  return data;
}
